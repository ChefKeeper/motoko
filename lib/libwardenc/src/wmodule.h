/*
 * Copyright (C) 2010 gonzoj
 *
 * Please check the CREDITS file for further information.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef WMODULE_H_
#define WMODULE_H_

#include "wtypes.h"

#define DWORD(a, i) (*((dword *)&(a[(i)])))

/* actually thiscall - we omit the this pointer (wfunc_list **) and push the other arguments via stdcall */
typedef __attribute__((stdcall)) void (*w_init_RC4_keys_t)(void *, dword);
typedef __attribute__((stdcall)) void (*w_unload_module_t)();
typedef __attribute__((stdcall)) void (*w_packet_handler_t)(byte *, dword, dword *);
typedef __attribute__((stdcall)) void (*w_tick_t)(dword);

typedef struct {
	w_init_RC4_keys_t w_init_RC4_keys;
	w_unload_module_t w_unload_module;
	w_packet_handler_t w_packet_handler;
	w_tick_t w_tick;
} wfunc_list;

/* list of functions the Warden modules export */
extern wfunc_list **wfunc;

/* stores the 0x04 packet generated by the module's packet handler */
extern byte *wresponse;
extern size_t wresponse_size;

/* points to the set of RC4 keys the module generates when handling 0x05 */
extern byte *new_RC4keys;

/* validates the downloaded Warden module */
bool wmodule_validate_encrypted(byte *raw, size_t len, byte *name);

/* validates the module after it has been decrypted (still compressed) */
bool wmodule_validate_decrypted(byte *raw, size_t len, char *key_string);

/* zlib's inflate */
byte * wmodule_decompress(byte *raw, size_t len, size_t *len_uncompressed);

/* loads the module, adjusts globals and resolves WINAPI references */
byte * wmodule_load(byte *raw);

/* initializes the module after it has been loaded */
wfunc_list ** wmodule_init(byte *module);

/* initializes the modules RC4 key generation */
void wmodule_init_RC4keys(wfunc_list **wfunc, dword seed);

/* passes packets to the module's handler function */
dword wmodule_handle_packet(wfunc_list **wfunc, byte *packet, size_t len);

/* unloads the module */
void wmodule_unload(wfunc_list **wfunc);

/* checks if the requested module is already cached on disk */
bool wmodule_check_diskcache(char *path, byte *mod_name);

/* stores the received module on disk */
void wmodule_save_to_disk(char *path, byte *module, byte *name, size_t len);

/* loads the module from disk */
byte * wmodule_load_from_disk(char *path, byte *mod_name, size_t *size);

#endif /* WMODULE_H_ */
