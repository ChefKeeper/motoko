/*
 * Copyright (C) 2010 gonzoj
 *
 * Please check the CREDITS file for further information.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <dirent.h>
#include <openssl/md5.h>
#include <openssl/rsa.h>
#include <openssl/sha.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>
#include <zlib.h>

//#include "winapi.h"
#include "wardenc.h"
extern wardenc_callbacks *callbacks; 

#include "wmodule.h"
#include "wutil.h"

/* functions to validate, load and initialize Warden modules */

/* gcc doesn't support thiscall attribute, we have to emulate it */
#define THISCALL(func, this, args, ret) asm("movl %0, %%ecx" : : "m" (this) : "%ecx"); ret func args;

/* functions the Warden modules import */
typedef __attribute__((stdcall)) void (*w_send_packet_t)(byte *packet, dword size);
typedef __attribute__((stdcall)) bool (*w_check_module_t)(byte *module_name, dword _2);
typedef __attribute__((stdcall)) wfunc_list ** (*w_load_module_t)(byte *RC4_key, byte *module, dword size);
typedef __attribute__((stdcall)) void * (*w_malloc_t)(dword size);
typedef __attribute__((stdcall)) void (*w_free_t)(void *mem);
typedef __attribute__((stdcall)) void (*w_set_RC4_data_t)(void *RC4_keys, dword size);
typedef __attribute__((stdcall)) dword (*w_get_RC4_data_t)(void *buf, dword size);

typedef struct {
	w_send_packet_t w_send_packet;
	w_check_module_t w_check_module;
	w_load_module_t w_load_module;
	w_malloc_t w_malloc;
	w_free_t w_free;
	w_set_RC4_data_t w_set_RC4_data;
	w_get_RC4_data_t w_get_RC4_data;
} wimport_list;

typedef __attribute__((stdcall)) wfunc_list ** (*init_module_t)();

/* holds the 0x04 packet generated by the loaded module  */
byte *wresponse;
size_t wresponse_size;

/* functions we export to the module (NOTE: stdcall) */

void __attribute__((stdcall)) send_packet_export(byte *packet, dword size) {

	/* we save the the packet the module has built */
	wresponse_size = size;
	wresponse = (byte *) malloc(wresponse_size);
	memcpy(wresponse, packet, size);

	return;
}

bool __attribute__((stdcall)) check_module_export(byte *module_name, dword _2) {
	return TRUE;
}

wfunc_list ** __attribute__((stdcall)) load_module_export(byte *RC4_key, byte *module, dword size) {
	return NULL;
}

void * __attribute__((stdcall)) malloc_export(dword size) {

	/* allocate memory for the module */
	//return malloc(size);
	void *p = malloc(size);
	memset(p, 0, size);
	return p;
}

void __attribute__((stdcall)) free_export(void *mem) {

	/* free the memory occupied by the module */
	free(mem);
}

void __attribute__((stdcall)) set_RC4_data_export(void *RC4_keys, dword size) {
	size = size; // just to make sure the compiler doesn't kill this function
	return;
}

byte *new_RC4keys = NULL;

dword __attribute__((stdcall)) get_RC4_data_export(void *buf, dword *size) {

	/* we save the position of the module's RC4 keys */
	new_RC4keys = buf;

	/* we want the module to generate a new pair of keys */
	return 0;
}

bool wmodule_validate_encrypted(byte *raw, size_t len, byte *name) {
	MD5_CTX ctx;
	byte md[0x10];

	MD5_Init(&ctx);
	MD5_Update(&ctx, raw, len);
	MD5_Final(md, &ctx);

	int i;
	for(i = 0; i < 0x10; i++) {
		if (md[i] != name[i]) {
			return FALSE;
		}
	}
	return TRUE;
}

static const byte rsa_n[] = {
		0x6B, 0xCE, 0xF5, 0x2D, 0x2A, 0x7D, 0x7A, 0x67,
		0x21, 0x21, 0x84, 0xC9, 0xBC, 0x25, 0xC7, 0xBC,
		0xDF, 0x3D, 0x8F, 0xD9, 0x47, 0xBC, 0x45, 0x48,
		0x8B, 0x22, 0x85, 0x3B, 0xC5, 0xC1, 0xF4, 0xF5,
		0x3C, 0x0C, 0x49, 0xBB, 0x56, 0xE0, 0x3D, 0xBC,
		0xA2, 0xD2, 0x35, 0xC1, 0xF0, 0x74, 0x2E, 0x15,
		0x5A, 0x06, 0x8A, 0x68, 0x01, 0x9E, 0x60, 0x17,
		0x70, 0x8B, 0xBD, 0xF8, 0xD5, 0xF9, 0x3A, 0xD3,
		0x25, 0xB2, 0x66, 0x92, 0xBA, 0x43, 0x8A, 0x81,
		0x52, 0x0F, 0x64, 0x98, 0xFF, 0x60, 0x37, 0xAF,
		0xB4, 0x11, 0x8C, 0xF9, 0x2E, 0xC5, 0xEE, 0xCA,
		0xB4, 0x41, 0x60, 0x3C, 0x7D, 0x02, 0xAF, 0xA1,
		0x2B, 0x9B, 0x22, 0x4B, 0x3B, 0xFC, 0xD2, 0x5D,
		0x73, 0xE9, 0x29, 0x34, 0x91, 0x85, 0x93, 0x4C,
		0xBE, 0xBE, 0x73, 0xA9, 0xD2, 0x3B, 0x27, 0x7A,
		0x47, 0x76, 0xEC, 0xB0, 0x28, 0xC9, 0xC1, 0xDA,
		0xEE, 0xAA, 0xB3, 0x96, 0x9C, 0x1E, 0xF5, 0x6B,
		0xF6, 0x64, 0xD8, 0x94, 0x2E, 0xF1, 0xF7, 0x14,
		0x5F, 0xA0, 0xF1, 0xA3, 0xB9, 0xB1, 0xAA, 0x58,
		0x97, 0xDC, 0x09, 0x17, 0x0C, 0x04, 0xD3, 0x8E,
		0x02, 0x2C, 0x83, 0x8A, 0xD6, 0xAF, 0x7C, 0xFE,
		0x83, 0x33, 0xC6, 0xA8, 0xC3, 0x84, 0xEF, 0x29,
		0x06, 0xA9, 0xB7, 0x2D, 0x06, 0x0B, 0x0D, 0x6F,
		0x70, 0x9E, 0x34, 0xA6, 0xC7, 0x31, 0xBE, 0x56,
		0xDE, 0xDD, 0x02, 0x92, 0xF8, 0xA0, 0x58, 0x0B,
		0xFC, 0xFA, 0xBA, 0x49, 0xB4, 0x48, 0xDB, 0xEC,
		0x25, 0xF3, 0x18, 0x8F, 0x2D, 0xB3, 0xC0, 0xB8,
		0xDD, 0xBC, 0xD6, 0xAA, 0xA6, 0xDB, 0x6F, 0x7D,
		0x7D, 0x25, 0xA6, 0xCD, 0x39, 0x6D, 0xDA, 0x76,
		0x0C, 0x79, 0xBF, 0x48, 0x25, 0xFC, 0x2D, 0xC5,
		0xFA, 0x53, 0x9B, 0x4D, 0x60, 0xF4, 0xEF, 0xC7,
		0xEA, 0xAC, 0xA1, 0x7B, 0x03, 0xF4, 0xAF, 0xC7
};

static const byte rsa_e[] = {
		0x01, 0x00, 0x01, 0x00
};

void reverse_bytes(byte *a, byte *b, size_t len) {
	int i;
	for (i = 0; i < len; i++) {
		b[len - i - 1] = a[i];
	}
}

bool wmodule_validate_decrypted(byte *raw, size_t len, char *key_string) {
	int data_len = len - 0x108;

	char *NGIS = (char *) raw + 4 + data_len;
	byte *signature = raw + 4 + data_len + 4;

	byte *rsa_md, *rsa_tmp, rsa_sig[0x100];
	byte sha1_md[0x100];

	int i;
	for (i = 0; i < sizeof(rsa_sig); i++) {
		/* this might be incorrect, should be 0xBB all the way according to skullsecurity */
		sha1_md[i] = i < sizeof(rsa_sig) - 1 ? 0xBB : 0x0B;
	}

	/* first a simple string check */
	if (memcmp(NGIS, "NGIS", 4)) {
		return FALSE;
	}

	/* apply RSA to the transmitted signature */
	RSA *key = RSA_new();
	byte rsa_mod[sizeof(rsa_n)], rsa_exp[sizeof(rsa_e)];
	reverse_bytes((byte *) rsa_n, rsa_mod, sizeof(rsa_n));
	reverse_bytes((byte *) rsa_e, rsa_exp, sizeof(rsa_e));
	reverse_bytes(signature, rsa_sig, sizeof(rsa_sig));
	key->n = BN_bin2bn(rsa_mod, sizeof(rsa_mod), key->n);
	key->e = BN_bin2bn(rsa_exp, sizeof(rsa_exp), key->e);
	rsa_md = (byte *) malloc(RSA_size(key));
	rsa_tmp = (byte *) malloc(RSA_size(key));
	RSA_public_encrypt(sizeof(rsa_sig), rsa_sig, rsa_tmp, key, RSA_NO_PADDING);
	reverse_bytes(rsa_tmp, rsa_md, RSA_size(key));
	free(rsa_tmp);
	RSA_free(key);

	/* apply SHA-1 to the module data including its size */
	SHA_CTX ctx;
	SHA1_Init(&ctx);
	SHA1_Update(&ctx, raw, 4 + data_len);
	SHA1_Update(&ctx, key_string, strlen(key_string));
	SHA1_Final(sha1_md, &ctx);

	/* compare the digests */
	for (i = 0; i < 0x100; i++) {
		if (sha1_md[i] != rsa_md[i]) {
			free(rsa_md);
			return FALSE;
		}
	}
	free(rsa_md);
	return TRUE;
}

#define CHUNK 262144 // 256 KB

byte * wmodule_decompress(byte *raw, size_t len, size_t *len_uncompressed) {
	z_stream stream;
	byte *module = NULL, out[CHUNK];
	int uncompressed = 0, ret;

	stream.zalloc = Z_NULL;
	stream.zfree = Z_NULL;
	stream.opaque = Z_NULL;
	stream.avail_in = len;
	stream.next_in = raw;
	if (inflateInit(&stream) != Z_OK) {
		return NULL;
	}

	do {
		do {
			stream.avail_out = CHUNK;
			stream.next_out = out;
			ret = inflate(&stream, Z_NO_FLUSH);
			switch (ret) {
				case Z_STREAM_ERROR:
				case Z_NEED_DICT:
				case Z_DATA_ERROR:
				case Z_MEM_ERROR:
					inflateEnd(&stream);
					if (module) {
						free(module);
					}
					return NULL;
			}

			int have = CHUNK - stream.avail_out;
			module = (byte *) realloc(module, uncompressed + have);
			memcpy(module + uncompressed, out, have);
			uncompressed += have;

		} while (stream.avail_out == 0);
	} while (ret != Z_STREAM_END);

	inflateEnd(&stream);

	*len_uncompressed = uncompressed;
	return module;
}

byte * wmodule_load(byte *raw) {
	/* allocate space for the module */
	dword size = DWORD(raw, 0);
	byte *module = (byte *) malloc(size);
	memset(module, 0, size);

	/* change the access protection for the affected pages */
	if (mprotect((void *) ((dword) module & ~0xFFF), size, PROT_READ | PROT_WRITE | PROT_EXEC)) {
		free(module);
		return NULL;
	}

	memcpy(module, raw, 40);

	dword src_off = 0x28 + (DWORD(module, 0x24) * 12);
	dword dest_off = DWORD(raw, 0x28);
	dword limit = DWORD(raw, 0);

	bool skip = FALSE;

	/* copying code section */
	while (dest_off < limit) {
		dword count = ((raw[src_off] & 0x0FF) << 0) | ((raw[src_off + 1] & 0x0FF) << 8);

		src_off += 2;

		if (!skip) {
			memcpy(module + dest_off, raw + src_off, count);
			src_off += count;
		}

		skip = !skip;

		dest_off += count;
	}

	src_off = DWORD(raw, 8);
	dest_off = 0;

	/* adjusting references to global variables */
	int i;
	for (i = 0; i < DWORD(module, 0x0C); i++) {
		if (((char) module[src_off]) < 0) {
			dest_off = ((module[src_off + 0] & 0x07F) << 24) | ((module[src_off + 1] & 0x0FF) << 16) | ((module[src_off + 2] & 0x0FF) << 8) | ((module[src_off + 3] & 0x0FF) << 0);
			src_off += 4;
		} else {
			dest_off += (module[src_off + 1] & 0x0FF) + (module[src_off] << 8);
			src_off += 2;
		}
		/**(dword *)&module[dest_off]*/ DWORD(module, dest_off) = (dword) module + DWORD(module, dest_off);
	}

	limit = DWORD(module, 0x20);

	/* updating library references */
	for (i = 0; i < limit; i++) {
		dword dyn_base = DWORD(module, 0x1C) + (i * 8);
		dword dyn_off = DWORD(module, dyn_base + 4);
		char *lib = (char *) (module + DWORD(module, dyn_base));

		while (DWORD(module, dyn_off)) {
			dword dyn = DWORD(module, dyn_off);

			if (dyn > 0 && dyn < size) {
				char *func = (char *) (module + dyn);

				/* we fix the reference with our own WINAPI implementations */
				DWORD(module, dyn_off) = (dword) callbacks->get_proc_address(lib, func);
			} else {
				dyn &= 0x7FFFFFFF;

			}

			dyn_off += 4;
		}
	}

	return module;
}

static wimport_list wtable;

static wimport_list *p_wtable;

/* this pointer expected by the module's imported functions */
static wimport_list **this;

/* this pointer we have to pass when calling the module's exported functions */
wfunc_list **wfunc;

wfunc_list ** wmodule_init(byte *module) {
	dword ecx, edx, ebp;

	ebp = DWORD(module, 0x18);
	edx = 1 - ebp;

	if (edx > DWORD(module, 0x14)) {
		return NULL;
	}

	ecx = DWORD(module, 0x10);
	ecx = (dword) module + DWORD(module, ecx + (edx * 4));

	init_module_t init_module = (init_module_t) ecx;

	memset(&wtable, 0, sizeof(wimport_list));

	wtable = (wimport_list) {
		(w_send_packet_t) send_packet_export,
		(w_check_module_t) check_module_export,
		(w_load_module_t) load_module_export,
		(w_malloc_t) malloc_export,
		(w_free_t) free_export,
		(w_set_RC4_data_t) set_RC4_data_export,
		(w_get_RC4_data_t) get_RC4_data_export
	};

	p_wtable = &wtable;
	this = &p_wtable;

	THISCALL(init_module, this, (), return)
}

void wmodule_init_RC4keys(wfunc_list **wfuncl, dword seed) {
	/* generate RC4 Keys */
	THISCALL((*wfuncl)->w_init_RC4_keys, wfuncl, (&seed, sizeof(dword)), )
}

dword wmodule_handle_packet(wfunc_list **wfuncl, byte *packet, size_t len) {
	/* used to handle 0x05 packet */
	dword read;
	THISCALL((*wfuncl)->w_packet_handler, wfuncl, (packet, len, &read), )
	return read;
}

void wmodule_unload(wfunc_list **wfuncl) {
	THISCALL((*wfuncl)->w_unload_module, wfuncl, (), )
	new_RC4keys = NULL;
}

/* functions for saving / loading Warden modules from disk */

bool wmodule_check_diskcache(char *path, byte *mod_name) {
	char *dir = strconcat(path, "modules");
	char *mod = strhexname(mod_name);

	struct dirent *dent;
	DIR *d;

	d = opendir(dir);
	if (d) {
		while ((dent = readdir(d))) {
			if (!strcmp(dent->d_name, mod)) {
				closedir(d);

				free(dir);
				free(mod);

				return TRUE;
			}
		}
		closedir(d);
	} else {
		mkdir(dir, S_IRWXU);
	}

	free(dir);
	free(mod);

	return FALSE;
}

void wmodule_save_to_disk(char *path, byte *module, byte *name, size_t len) {
	char *s_mod = strhexname(name);
	char *dir = strconcat(path, "modules");
	char *file = strconcat(dir, s_mod);

	FILE *f = fopen(file, "wb");
	if (f) {
		int i;
		for (i = 0; i < len; i++) {
			fprintf(f, "%c", module[i]);
		}
		fclose(f);
	}

	free(s_mod);
	free(dir);
	free(file);
}

byte * wmodule_load_from_disk(char *path, byte *mod_name, size_t *size) {
	char *dir = strconcat(path, "modules");
	char *name = strhexname(mod_name);
	char *s_mod = strconcat(dir, name);

	byte *mod = NULL;
	*size = 0;

	FILE *f = fopen(s_mod, "rb");
	if (f) {
		while (!feof(f)) {
			*size += 1;
			mod = (byte *) realloc(mod, *size);
			if (!fscanf(f, "%c", mod + *size - 1)) { // to make gcc happy
				fclose(f);

				free(dir);
				free(name);
				free(s_mod);
				if (mod) free(mod);

				return NULL;
			}
		}
		fclose(f);
	}

	free(dir);
	free(name);
	free(s_mod);

	return mod;
}
